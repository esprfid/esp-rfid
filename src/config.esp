bool ICACHE_FLASH_ATTR loadConfiguration(Config &config)
{
	File configFile = SPIFFS.open("/config.json", "r");
	if (!configFile)
	{
#ifdef DEBUG
		Serial.println(F("[ WARN ] Failed to open config file"));
#endif
		return false;
	}
	size_t size = configFile.size();
	std::unique_ptr<char[]> buf(new char[size]);
	configFile.readBytes(buf.get(), size);
	DynamicJsonDocument json(4096);
	auto error = deserializeJson(json, buf.get());
	if (error)
	{
#ifdef DEBUG
		Serial.println(F("[ WARN ] Failed to parse config file"));
#endif
		return false;
	}
#ifdef DEBUG
	Serial.println(F("[ INFO ] Config file found"));
	serializeJsonPretty(json, Serial);
	Serial.println();
#endif
	JsonObject network = json["network"];
	JsonObject hardware = json["hardware"];
	JsonObject general = json["general"];
	JsonObject mqtt = json["mqtt"];
	JsonObject ntp = json["ntp"];
#ifdef DEBUG
	Serial.println(F("[ INFO ] Trying to setup RFID Hardware"));
#endif
	if (hardware.containsKey("wifipin"))
	{
		config.wifipin = hardware["wifipin"];
		if (config.wifipin != 255)
		{
			pinMode(config.wifipin, OUTPUT);
			digitalWrite(config.wifipin, LEDoff);
		}
	}

	if (hardware.containsKey("doorstatpin"))
	{
		config.doorstatpin = hardware["doorstatpin"];
		if (config.doorstatpin != 255)
		{
			pinMode(config.doorstatpin, INPUT);
		}
	}

	if (hardware.containsKey("maxOpenDoorTime"))
	{
		config.maxOpenDoorTime = hardware["maxOpenDoorTime"];
		Serial.print("maxOpenDoorTime = ");
		Serial.println(config.maxOpenDoorTime);
	}

	if (hardware.containsKey("doorbellpin"))
	{
		config.doorbellpin = hardware["doorbellpin"];
		if (config.doorbellpin != 255)
		{
			pinMode(config.doorbellpin, INPUT);
		}
	}

	if (hardware.containsKey("accessdeniedpin"))
	{
		config.accessdeniedpin = hardware["accessdeniedpin"];
		if (config.accessdeniedpin != 255)
		{
			pinMode(config.accessdeniedpin, OUTPUT);
			digitalWrite(config.accessdeniedpin, LOW);
		}
	}

	if (hardware.containsKey("beeperpin"))
	{
		config.beeperpin = hardware["beeperpin"];
		if (config.beeperpin != 255)
		{
			pinMode(config.beeperpin, OUTPUT);
			digitalWrite(config.beeperpin, BEEPERoff);
		}
	}

	if (hardware.containsKey("ledwaitingpin"))
	{
		config.ledwaitingpin = hardware["ledwaitingpin"];
		if (config.ledwaitingpin != 255)
		{
			pinMode(config.ledwaitingpin, OUTPUT);
			digitalWrite(config.ledwaitingpin, LEDoff);
		}
	}

	if (hardware.containsKey("openlockpin"))
	{
		config.openlockpin = hardware["openlockpin"];
		if (config.openlockpin != 255)
		{
			openLockButton = Bounce();
			openLockButton.attach(config.openlockpin, INPUT_PULLUP);
			openLockButton.interval(30);
		}
	}

	if (hardware.containsKey("numrelays"))
	{
		config.numRelays = hardware["numrelays"];
	}
	else
		config.numRelays = 1;

#ifdef OFFICIALBOARD
	config.pinCodeRequested = hardware["pincoderequested"];
	setupWiegandReader(5, 4);
#endif
#ifndef OFFICIALBOARD
	config.readertype = hardware["readertype"];
	int rfidss;
	if (config.readertype == READER_WIEGAND || config.readertype == READER_WIEGAND_RDM6300)
	{
		int wgd0pin = hardware["wgd0pin"];
		int wgd1pin = hardware["wgd1pin"];
		config.pinCodeRequested = hardware["pincoderequested"];
		setupWiegandReader(wgd0pin, wgd1pin); // also some other settings like weather to use keypad or not, LED pin, BUZZER pin, Wiegand 26/34 version
	}
	else if (config.readertype == READER_MFRC522 || config.readertype == READER_MFRC522_RDM6300)
	{
		rfidss = 15;
		if (hardware.containsKey("sspin"))
		{
			rfidss = hardware["sspin"];
		}
		int rfidgain = hardware["rfidgain"];
		setupMFRC522Reader(rfidss, rfidgain);
	}
	else if (config.readertype == READER_PN532 || config.readertype == READER_PN532_RDM6300)
	{
		rfidss = hardware["sspin"];
		setupPN532Reader(rfidss);
	}
#ifndef DEBUG
	if (config.readertype > 2)
		Serial.begin(9600);
#endif
#endif
	config.autoRestartIntervalSeconds = general["restart"];
	config.wifiTimeout = network["offtime"];
	const char *bssidmac = network["bssid"];
	byte bssid[6] = {0, 0, 0, 0, 0, 0};
	if (strlen(bssidmac) > 0)
		parseBytes(bssidmac, ':', bssid, 6, 16);
	config.deviceHostname = strdup(general["hostnm"]);
	WiFi.hostname(config.deviceHostname);
	if (!MDNS.begin(config.deviceHostname))
	{
#ifdef DEBUG
		Serial.println("[ WARN ] Error setting up MDNS responder!");
#endif
	}
	MDNS.addService("http", "tcp", 80);
	const char *ntpserver = ntp["server"];
	int ntpinter = ntp["interval"];
	config.timeZone = ntp["timezone"];
	config.activateTime[0] = hardware["rtime"];
	config.lockType[0] = hardware["ltype"];
	config.relayType[0] = hardware["rtype"];

#ifndef OFFICIALBOARD
	config.relayPin[0] = hardware["rpin"];
	pinMode(config.relayPin[0], OUTPUT);
	digitalWrite(config.relayPin[0], !config.relayType[0]);

	for (int i = 1; i < config.numRelays; i++)
	{
		JsonObject relay = hardware["relay" + String((i + 1))];
		config.activateTime[i] = relay["rtime"];
		config.lockType[i] = relay["ltype"];
		config.relayType[i] = relay["rtype"];
		config.relayPin[i] = relay["rpin"];
		pinMode(config.relayPin[i], OUTPUT);
		digitalWrite(config.relayPin[i], !config.relayType[i]);
	}

#endif
	const char *ssid = network["ssid"];
	const char *password = network["pswd"];
	config.wmode = network["wmode"];
	config.httpPass = strdup(general["pswd"]);
	ws.setAuthentication("admin", config.httpPass);
	if (config.wmode == 1)
	{
		int hid = network["hide"];
#ifdef DEBUG
		Serial.println(F("[ INFO ] ESP-RFID is running in AP Mode "));
#endif
		const char *apipch;
		if (network.containsKey("apip"))
		{
			apipch = network["apip"];
		}
		else
		{
			apipch = "192.168.4.1";
		}
		const char *apsubnetch;
		if (network.containsKey("apsubnet"))
		{
			apsubnetch = network["apsubnet"];
		}
		else
		{
			apsubnetch = "255.255.255.0";
		}
		IPAddress apip;
		IPAddress apsubnet;
		apip.fromString(apipch);
		apsubnet.fromString(apsubnetch);
		return startAP(apip, apsubnet, hid, ssid, password);
	}
	else
	{
		if (network["dhcp"] == "0")
		{
			WiFi.mode(WIFI_STA);
			const char *clientipch = network["ip"];
			const char *subnetch = network["subnet"];
			const char *gatewaych = network["gateway"];
			const char *dnsch = network["dns"];
			IPAddress clientip;
			IPAddress subnet;
			IPAddress gateway;
			IPAddress dns;
			clientip.fromString(clientipch);
			subnet.fromString(subnetch);
			gateway.fromString(gatewaych);
			dns.fromString(dnsch);
			WiFi.config(clientip, gateway, subnet, dns);
		}
		if (!connectSTA(ssid, password, bssid))
		{
			return false;
		}
	}
#ifdef DEBUG
	Serial.println("[ INFO ] Trying to setup NTP Server");
#endif
	NTP.Ntp(ntpserver, config.timeZone, ntpinter * 60);

	if (mqtt["enabled"] == 1)
		config.mqttEnabled = true;
	else
		config.mqttEnabled = false;
	if (config.mqttEnabled)
	{
#ifdef DEBUG
		Serial.println("[ INFO ] Trying to setup MQTT");
#endif
		String mhsString = mqtt["host"];
		config.mqttHost = strdup(mhsString.c_str());
		config.mqttPort = mqtt["port"];
		String muserString = mqtt["user"];
		config.mqttUser = strdup(muserString.c_str());
		String mpasString = mqtt["pswd"];
		config.mqttPass = strdup(mpasString.c_str());
		String mqttTopicString = mqtt["topic"];
		config.mqttTopic = strdup(mqttTopicString.c_str());
		config.mqttInterval = mqtt["syncrate"];

		if (mqtt["mqttlog"] == 1)
			config.mqttEvents = true;
		else
			config.mqttEvents = false;

		if (mqtt["mqttha"] == 1)
			config.mqttHA = true;
		else
			config.mqttHA = false;

		if (config.mqttHA)
		{
			String mtopic(config.mqttTopic);
			String topicString = mtopic + "/avty";
			String payloadString = "offline";
			char *topicLWT = strdup(topicString.c_str());
			char *payloadLWT = strdup(payloadString.c_str());
			mqttClient.setWill(topicLWT, 2, true, payloadLWT);
		}
		mqttClient.setServer(config.mqttHost, config.mqttPort);
		mqttClient.setCredentials(config.mqttUser, config.mqttPass);
		mqttClient.onDisconnect(onMqttDisconnect);
		mqttClient.onPublish(onMqttPublish);
		mqttClient.onSubscribe(onMqttSubscribe);
		mqttClient.onConnect(onMqttConnect);
		mqttClient.onMessage(onMqttMessage);

#ifdef DEBUG
		Serial.println("[ INFO ] try to call mqttconnect ");
#endif
		connectToMqtt();
	}
#ifdef DEBUG
	Serial.println(F("[ INFO ] Configuration done."));
#endif
	return true;
}
